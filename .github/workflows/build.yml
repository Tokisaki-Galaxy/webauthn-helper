#
# Description: Auto compile webauthn-helper for multiple architectures using cross-rs
#
name: "Build webauthn-helper"
on:
  push:
    branches: [ "main", "master" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "main", "master" ]
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH connection to Actions'
        required: false
        default: 'false'

permissions:
  contents: write

env:
  TZ: Asia/Shanghai
  PROJECT_NAME: webauthn-helper

jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.set_version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set version
        id: set_version
        run: |
          if [ "${{ github.ref_type }}" = "tag" ]; then
            # Tag trigger: use tag name as version (strip 'v' prefix)
            VERSION=$(echo "${{ github.ref_name }}" | sed 's/^v//')
            echo "Build triggered by Tag: Using Version=$VERSION"
          else
            # Non-tag trigger: use date + run_number + short SHA
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev.${{ github.run_number }}.g${SHORT_SHA}"
            echo "Build triggered by Commit: Using Version=$VERSION"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

  build:
    name: Build ${{ matrix.target }}
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # x86_64 architecture
          - target: x86_64-unknown-linux-musl
          # AArch64 (ARM64) architecture
          - target: aarch64-unknown-linux-musl
          # ARM 32-bit architecture
          - target: armv7-unknown-linux-musleabihf
          - target: armv7-unknown-linux-musleabi
          - target: armv5te-unknown-linux-musleabi
          - target: arm-unknown-linux-musleabi
          - target: arm-unknown-linux-musleabihf
          # MIPS 32-bit architectures (cross-rs Docker + nightly build-std via Cross.toml)
          - target: mips-unknown-linux-musl
            use_nightly: true
          - target: mipsel-unknown-linux-musl
            use_nightly: true
          # RISC-V architecture (no cross-rs Docker image, use cargo + musl-cc)
          - target: riscv64gc-unknown-linux-musl
            musl_cc: riscv64-linux-musl-cross
            musl_cc_linker: riscv64-linux-musl-gcc
          # PowerPC architecture (no cross-rs Docker image, use cargo + musl-cc)
          - target: powerpc64le-unknown-linux-musl
            musl_cc: powerpc64le-linux-musl-cross
            musl_cc_linker: powerpc64le-linux-musl-gcc
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set version in Cargo.toml
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          sed -i "s/^version = .*/version = \"${VERSION}\"/" Cargo.toml
          echo "Updated Cargo.toml version to: $VERSION"
          grep '^version' Cargo.toml

      - name: Install Rust stable toolchain
        if: ${{ !matrix.use_nightly }}
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Rust nightly toolchain
        if: ${{ matrix.use_nightly }}
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src

      - name: Install cross
        if: ${{ !matrix.musl_cc }}
        uses: taiki-e/install-action@cross

      - name: Install musl-cross toolchain
        if: ${{ matrix.musl_cc }}
        run: |
          sudo mkdir -p /opt/musl-cross
          curl -fsSL "https://github.com/timsaya/musl-cc/releases/download/v0.1.0/${{ matrix.musl_cc }}.tgz" \
            | sudo tar xz -C /opt/musl-cross

      - name: Configure cargo linker
        if: ${{ matrix.musl_cc }}
        run: |
          mkdir -p .cargo
          cat > .cargo/config.toml << 'TOML'
          [target.${{ matrix.target }}]
          linker = "/opt/musl-cross/${{ matrix.musl_cc }}/bin/${{ matrix.musl_cc_linker }}"
          rustflags = ["-C", "link-args=-lm", "-C", "panic=unwind"]
          TOML
          cat .cargo/config.toml

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "${{ runner.os }}-${{ matrix.target }}"

      - name: Build with cross
        if: ${{ !matrix.musl_cc }}
        run: |
          if [ "${{ matrix.use_nightly }}" = "true" ]; then
            cross +nightly build -Z build-std=std,panic_abort --release --target ${{ matrix.target }}
          else
            cross build --release --target ${{ matrix.target }}
          fi

      - name: Build with cargo
        if: ${{ matrix.musl_cc }}
        run: cargo build --release --target ${{ matrix.target }}

      - name: Package
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          TARGET="${{ matrix.target }}"
          PACKAGE_DIR="${PROJECT_NAME}-${VERSION}-${TARGET}"

          mkdir -p "release/${PACKAGE_DIR}"
          cp "target/${TARGET}/release/${PROJECT_NAME}" "release/${PACKAGE_DIR}/"
          cp LICENSE "release/${PACKAGE_DIR}/" 2>/dev/null || true
          cp README.md "release/${PACKAGE_DIR}/" 2>/dev/null || true

          tar -czvf "release/${PROJECT_NAME}-${VERSION}-${TARGET}.tar.gz" -C release "${PACKAGE_DIR}"
          rm -rf "release/${PACKAGE_DIR}"

          echo "ðŸ“¦ Package: ${PROJECT_NAME}-${VERSION}-${TARGET}.tar.gz"
          ls -lh "release/${PROJECT_NAME}-${VERSION}-${TARGET}.tar.gz"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PROJECT_NAME }}-${{ matrix.target }}
          path: release/*.tar.gz

  compress:
    name: UPX Compress
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4.1.7
        with:
          path: artifacts
          pattern: ${{ env.PROJECT_NAME }}-*
          merge-multiple: true

      - name: Install UPX
        run: |
          sudo apt-get update
          sudo apt-get install -y upx-ucl
          upx --version

      - name: Extract, compress and display comparison
        env:
          PROJECT_NAME: ${{ env.PROJECT_NAME }}
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          mkdir -p workdir release

          echo "=========================================="
          echo "ðŸ—œï¸  UPX COMPRESSION SUMMARY"
          echo "=========================================="
          printf "| %-40s | %-12s | %-12s | %-10s |\n" "Target" "Before (KB)" "After (KB)" "Ratio"
          printf "| %-40s | %-12s | %-12s | %-10s |\n" "----------------------------------------" "------------" "------------" "----------"

          for tarball in artifacts/*.tar.gz; do
            if [ -f "$tarball" ]; then
              BASENAME=$(basename "$tarball" .tar.gz)
              TARGET=$(echo "$BASENAME" | sed "s/${PROJECT_NAME}-${VERSION}-//")

              # Extract the tarball
              tar -xzf "$tarball" -C workdir/

              # Find the executable (should be in workdir/PROJECT_NAME-VERSION-TARGET/)
              PACKAGE_DIR=$(find workdir -maxdepth 1 -type d -name "${PROJECT_NAME}-*" | head -n 1)
              EXECUTABLE="${PACKAGE_DIR}/${PROJECT_NAME}"

              if [ -f "$EXECUTABLE" ]; then
                # Get size before compression
                SIZE_BEFORE=$(stat -c%s "$EXECUTABLE")
                SIZE_BEFORE_KB=$((SIZE_BEFORE / 1024))

                # Compress with UPX (skip if unsupported architecture)
                # Using --best --lzma for maximum compression ratio
                if upx --best --lzma "$EXECUTABLE" 2>/dev/null; then
                  # Get size after compression
                  SIZE_AFTER=$(stat -c%s "$EXECUTABLE")
                  SIZE_AFTER_KB=$((SIZE_AFTER / 1024))

                  # Calculate compression ratio
                  RATIO=$(awk "BEGIN {printf \"%.1f%%\", (1 - $SIZE_AFTER / $SIZE_BEFORE) * 100}")

                  printf "| %-40s | %10s KB | %10s KB | %9s |\n" "$TARGET" "$SIZE_BEFORE_KB" "$SIZE_AFTER_KB" "$RATIO"
                else
                  # UPX failed (architecture not supported)
                  printf "| %-40s | %10s KB | %12s | %10s |\n" "$TARGET" "$SIZE_BEFORE_KB" "unsupported" "N/A"
                fi

                # Re-package the compressed files
                cd workdir
                if ! tar -czvf "../release/${BASENAME}.tar.gz" "$(basename "$PACKAGE_DIR")"; then
                  echo "Error: Failed to create tarball for ${TARGET}"
                  exit 1
                fi
                cd ..
              fi

              # Clean up extracted files
              rm -rf workdir/*
            fi
          done

          echo "=========================================="

      - name: Upload compressed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: compressed-artifacts
          path: release/*.tar.gz

  release:
    name: Release
    needs: [prepare, compress]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download compressed artifacts
        uses: actions/download-artifact@v4.1.7
        with:
          path: release
          pattern: compressed-artifacts
          merge-multiple: true

      #- name: Prepare release notes
      #  run: |
      #    echo "![](https://img.shields.io/github/downloads/${{ github.repository }}/${{ github.ref_name }}/total?style=flat-square)" >> release.txt

      - name: Publish Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          generate_release_notes: true
          #body_path: release.txt
          files: release/*

      - name: Notify OpenWrt Project
        run: |
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/Tokisaki-Galaxy/openwrt-webauthn-helper/dispatches \
            -d '{"event_type":"sync-upstream"}'
